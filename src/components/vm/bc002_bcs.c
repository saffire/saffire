/**
 * Generated bytecode from src/components/vm/bc002.bcs
 */


t_bytecode *generate_dummy_bytecode_bc002_bcs_main(void);
/**
 *
 */
t_bytecode *generate_dummy_bytecode_bc002_bcs_main(void) {
    char byte_code[] = 
        "\x81\x00\x00"         // LOAD_CONST          10
        "\x80\x00\x00"         // STORE_ID            a
        "\x81\x01\x00"         // LOAD_CONST          50
        "\x80\x01\x00"         // STORE_ID            b
        "\x82\x00\x00"         // LOAD_ID             a
        "\x82\x01\x00"         // LOAD_ID             b
        "\x17"                 // BINARY_ADD
        "\x80\x02\x00"         // STORE_ID            c
        "\x81\x02\x00"         // LOAD_CONST          25
        "\x82\x02\x00"         // LOAD_ID             c
        "\x95\x03\x00"         // COMPARE_OP          OP_GT
        "\x85\x04\x00"         // JUMP_IF_FALSE       #no_ret
        "\x81\x03\x00"         // LOAD_CONST          "Jah!"
        "\x73"                 // RETURN
    // #no_ret:
        "\x81\x04\x00"         // LOAD_CONST          "Neen"
        "\x73"                 // RETURN
    ;
    t_bytecode *bc = (t_bytecode *)smm_malloc(sizeof(t_bytecode));
    bzero(bc, sizeof(t_bytecode));
    bc->stack_size = 25;
    bc->code_len = sizeof(byte_code);
    bc->code = smm_malloc(bc->code_len);
    memcpy(bc->code, byte_code, bc->code_len);

    bc->constants = NULL;   // Important to start constants and identifiers on NULL
    bc->identifiers = NULL;

    // constants
    _new_constant_long(bc, 10);
    _new_constant_long(bc, 50);
    _new_constant_long(bc, 25);
    _new_constant_string(bc, "Jah!");
    _new_constant_string(bc, "Neen");

    // identifier names
    _new_name(bc, "a");
    _new_name(bc, "b");
    _new_name(bc, "c");
    _new_name(bc, "OP_GT");
    
    return bc;
}




